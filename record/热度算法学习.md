## 热度算法



#### 用途

- 可以用来计算话题热度
- 可以作为推荐算法的冷启动



#### 有关feed流

*说明：参考[博客1](https://www.zhihu.com/question/20690652)，[博客2](https://www.zhihu.com/question/19645686)。*

​	**Feed**，源自早期的**RSS**。是一种呈现内容给用户并持续更新的方式，用户可以选择订阅多个资源，网站提供feed 网址 ，用户将feed网址登记到阅读器里，在阅读器里形成的聚合页就是feed流。2006年 Facebook重新定义了feed，叫**News Feed**，我们如今广泛使用的模式和这个类似。它有几个特点：订阅源不再是某个内容，而是生产内容的人/团体；订阅中通常夹杂非订阅内容，比如热门推荐、广告；内容也不再严格按照timeline，广泛使用智能feed排序。新的feed流刻意不再需要主动搜索，而是主动呈现琳琅满目的内容。

##### feed流主要模式

- 推（Push）
  - 例子：当一个用户触发行为（比如发微博），自身行为记录到行为表中，同时也对应到这个用户的粉丝表，为每个粉丝插入一条feed。但是对于粉丝过万的大V，为每个粉丝插入一条feed对存储数据成本很大。
- 拉（Pull）
  - 例子：当一个用户（特别是关注了很多人的）触发行为的时，拉取自己动态，检索用户的关注表，然后根据关注表检索新发的feed。如果一个用户关注过多的时候，查询该用户的关注列表也是有很大数据成本。
- 推拉结合（Hybrid）
  - 在线推，离线拉：大V发动态，只同步发布动态给同时在线的粉丝，离线的粉丝上线后，再去拉取动态来完成推与拉。
  - 定时推，离线拉：大V发动态之后，以常驻进程的方式定时推送到粉丝动态表。
  - 不管是什么模式，每个用户都会维护一个类似收件箱和发件箱的东西，用来保存自己发过的动态以及feed流动态



#### 算法1

*说明：参考[博客](http://www.woshipm.com/pmd/723735.html)。*



##### 基本原理

​	热度算法需要不断优化，基本原理如下图公式所示。这里以话题为例。
$$
Score = S_0 + S(Users) – S(Time)
$$
​	$Score$ 为话题最终的热度值，$S_0$ 为话题的初始热度， $S(Users)$ 为话题与用户交互产生的热度（如被点赞、评论、转发等， $S(Time)$ 为话题随时间衰减的热度分。

##### 初始热度$S_0$

- 不同博文的初始热度可以不同，对此可以将初始热度$S_0$设置为变量
  - 一些类别的话题本身容易比其他话题获得更高关注度，所以可以按照类别分类，给不同类别的话题以不同的初始热度
  - 对于如新闻的热度计算而言，存在一些重大事件的报道，需要在入库时就有更高的热度。提高此类报道的初始热度，可以使用*热词匹配*的办法：即一方面对大型新闻站点的头条、社交网站热点等等做监控和扒取，并将这批新闻的关键词维护到热词库，当每条新闻入库的时候（生成初始热度的时候），可以将新闻和热词库做一个匹配分析，匹配度越高初始热度越高

##### 用户交互热度$S(Users)$ 

- 首先明确哪些行为可以对话题热度产生影响：如发博文，对话题下的博文进行点赞、评论、转发等等。然后为不同行为赋予不同的分数：如$S(Users) = 5 * like + 10 * comment + 20 * forward + 30 * post$。

- 同时， 当用户规模不同时，需要维持用户对热度产生的影响相对稳定。在用户规模较小的时候，用户对话题热度的影响可以适当放大；而在用户规模变得庞大的时候需要减小每个用户对热度产生的影响。对这个问题的一个解决方式是可以将用户规模考虑到公式当中，比如将之前的公式改进为：

   $S(Users) = (1*click + 5*favor + 10*comment + 20*share)/DAU * N(固定数）$

##### 时间衰减 $S(Time)$

- 热度随时间的衰减可以近似为指数函数：$S(Time) = e ^ {k*(T1 – T0)}$，其中 $T1$ 为当前时间，$T0$ 为初始时间
- 热度的发展最终是一个无限趋近于零热度的结果，最终热度算法可以调整为：

$$
Score = ( S_0 + S(Users) ) / S(Time)
$$





#### 算法2

*说明：hacker news的排名算法，参考[博客](https://blog.csdn.net/ouzhuangzhuang/article/details/82467949)。*



##### 基本原理

​	和上面的算法1原理类似，不过时间影响因子的计算方式不太一样，公式如下：
$$
Score= \frac{(P−1)}{(T+2)^G}
$$

- $P$: 投票数，-1应该是想去掉文章提交者的那一票
- $T$: 发布到现在的时间间隔，单位小时，+2防止除数太小
- $G$: 重力加速度，它的数值大小决定了排名随时间下降的速度快慢





#### 算法3

*说明：Reddit的排名算法，参考[博客](https://www.zhihu.com/question/19936651)。*



##### 基本原理

![r_reddit formula](/Users/mac/Desktop/热度计算/r_reddit formula.png)

可以改进为如下算法：
$$
SRRank=log_{10}Z+ts/45000\\
ts = t_{publish} - t_{constant}\\
Z = Up - Down
$$
参数注解基本和Reddit一样，不同的就是没有反对票：

- 时间点 B，2008-12-01 00:00:00，是一个固定的值。ts 反映了文章的新鲜程度。引入 B 是一个非常优雅的技巧，它使得新鲜度的度量可以独立于系统当前时间。
- 45000 代表的是一个 12.5 小时周期内的总秒数。它 与 ts 一起使用，随着时间的推移，新文章的得分会逐渐超越高投票数的老文章，从而实现自动更新的效果。
- log10 的使用是另外一个技巧，它可以使得早期的投票获得更大的权重。比如，前 10 票获得的权重，与 11 到 101 票所获得的权重是一样的。


